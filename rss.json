{"title":"Hexo","description":"","language":"en","link":"http://example.com","webMaster":"John Doe","pubDate":"Sun, 07 May 2023 13:46:40 GMT","lastBuildDate":"Sun, 07 May 2023 14:28:42 GMT","generator":"hexo-generator-json-feed","items":[{"title":"Hello World","link":"http://example.com/2023/05/07/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","pubDate":"Sun, 07 May 2023 13:46:40 GMT","guid":"http://example.com/2023/05/07/hello-world/","category":[]},{"title":"1.6 Debug&基础练习","link":"http://example.com/2023/05/01/2023-0507-0716-1.6%20Debug&%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/","description":"1.Debug模式1.1 什么是Debug模式是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。 1.2 Debug介绍与操作流程 如何加断点 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可 如何运行加了断点的程序 在代码区域右键Debug执行 看哪里 看Debugger窗口 看Console窗口 点哪里 点Step Into (F7)这个箭头，也可以直接按F7 如何删除断点 选择要删除的断点，单击鼠标左键即可 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除 2. 进制的介绍与书写格式2.1 进制的介绍与书写格式代码 : 12345678910111213141516public class Demo1 &#123; /* 十进制：Java中，数值默认都是10进制，不需要加任何修饰。 二进制：数值前面以0b开头，b大小写都可以。 八进制：数值前面以0开头。 十六进制：数值前面以0x开头，x大小写都可以。 注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据. */ public static void main(String[] args) &#123; System.out.println(10); System.out.println(&quot;二进制数据0b10的十进制表示为:&quot; + 0b10); System.out.println(&quot;八进制数据010的十进制表示为:&quot; + 010); System.out.println(&quot;十六进制数据0x10的十进制表示为:&quot; + 0x10); &#125;&#125; 2.2 任意进制到十进制的转换 2.3 进制转换-十进制到任意进制转换​ 2.3.1 : 十进制到二进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。 ​ 需求：将十进制数字11，转换为2进制。 ​ 实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。 ​ 2.3.2 : 十进制到十六进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。 ​ 需求：将十进制数字60，转换为16进制。 ​ 实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。 ​ 结论：十进制到任意进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着 拼起来即可 2.4 快速进制转换法​ 8421码： ​ 8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。 ​ 2.5 原码反码补码前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的 **原码 **:（可直观看出数据大小） 就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。 通过一个字节表示+7和-7，代码：byte b1 &#x3D; 7; byte b2 &#x3D; -7;一个字节等于8个比特位，也就是8个二进制位 0(符号位) 0000111 1(符号位) 0000111 反码 : 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 : （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。 2.6 位运算-基本位运算符12345678910111213141516171819202122232425262728293031323334353637package com.itheima.demo;public class Demo2 &#123; /* 位运算: 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。 在二进制位运算中，1表示true，0表示false。 &amp; 位与 : 遇false则false, 遇0则0 00000000 00000000 00000000 00000110 // 6的二进制 &amp; 00000000 00000000 00000000 00000010 // 2的二进制 ----------------------------------------- 00000000 00000000 00000000 00000010 // 结果: 2 | 位或 : 遇true则true, 遇1则1 ^ 位异或 : 相同为false, 不同为true ~ 取反 : 全部取反, 0变1, 1变0 (也包括符号位) 00000000 00000000 00000000 00000110 // 6的二进制补码 ~ 11111111 11111111 11111111 11111001 - 1 // -1求反码 ------------------------------------ 11111111 11111111 11111111 11111000 // 反码推原码 10000000 00000000 00000000 00000111 // -7 */ public static void main(String[] args) &#123; System.out.println(6 &amp; 2); System.out.println(~6); &#125;&#125; 2.7 位运算-位移运算符位运算概述 : 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false。 位运算符介绍 : 代码 : 123456789101112131415161718192021222324252627282930313233package com.itheima.demo;public class Demo3 &#123; /* 位移运算符: &lt;&lt; 有符号左移运算，二进制位向左移动, 左边符号位丢弃, 右边补齐0 运算规律: 向左移动几位, 就是乘以2的几次幂 12 &lt;&lt; 2 (0)0000000 00000000 00000000 000011000 // 12的二进制 ----------------------------------------------------------------------------- &gt;&gt; 有符号右移运算，二进制位向右移动, 使用符号位进行补位 运算规律: 向右移动几位, 就是除以2的几次幂 000000000 00000000 00000000 0000001(1) // 3的二进制 ----------------------------------------------------------------------------- &gt;&gt;&gt; 无符号右移运算符, 无论符号位是0还是1，都补0 010000000 00000000 00000000 00000110 // -6的二进制 */ public static void main(String[] args) &#123; System.out.println(12 &lt;&lt; 1); // 24 System.out.println(12 &lt;&lt; 2); // 48 &#125;&#125; 12345678910111213package com.itheima.demo;public class Demo4 &#123; /* ^ 运算符的特点 一个数, 被另外一个数, 异或两次, 该数本身不变 */ public static void main(String[] args) &#123; System.out.println(10 ^ 5 ^ 10); &#125;&#125; 3.基础练习3.1 数据交换案例需求 ​ 已知两个整数变量a &#x3D; 10，b &#x3D; 20，使用程序实现这两个变量的数据交换 最终输出a &#x3D; 20，b &#x3D; 10; 代码实现 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.test;public class Test1 &#123; /* 需求：已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换 最终输出a = 20，b = 10; 思路： 1. 定义一个三方变量temp，将a原本记录的值，交给temp记录 （a的值，不会丢了） 2. 使用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） 3. 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） 4. 输出 a 和 b 变量即可 */ /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) &#123; int a = 10; int b = 20; // 将a原本记录的值，交给temp记录 （a的值，不会丢了） int temp = a; // 用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） a = b; // 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） b = temp; // 输出 a 和 b 变量即可 System.out.println(&quot;a=&quot; + a); System.out.println(&quot;b=&quot; + b); &#125;&#125; 3.2 数组反转【应用】案例需求 : ​ 已知一个数组 arr &#x3D; {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换， ​ 交换后的数组 arr &#x3D; {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素 实现步骤 : 1. 定义两个变量, start和end来表示开始和结束的指针. 确定交换条件, start &lt; end 允许交换 循环中编写交换逻辑代码 每一次交换完成, 改变两个指针所指向的索引 start++, end– 循环结束后, 遍历数组并打印, 查看反转后的数组 代码实现 : 1234567891011121314151617181920212223242526272829303132333435package com.itheima.test;public class Test2 &#123; /* 需求：已知一个数组 arr = &#123;19, 28, 37, 46, 50&#125;; 用程序实现把数组中的元素值交换， 交换后的数组 arr = &#123;50, 46, 37, 28, 19&#125;; 并在控制台输出交换后的数组元素。 步骤: 1. 定义两个变量, start和end来表示开始和结束的指针. 2. 确定交换条件, start &lt; end 允许交换 3. 循环中编写交换逻辑代码 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end-- 5. 循环结束后, 遍历数组并打印, 查看反转后的数组 */ public static void main(String[] args) &#123; int[] arr = &#123;19, 28, 37, 46, 50&#125;; // 1. 定义两个变量, start和end来表示开始和结束的指针. int start = 0; int end = arr.length -1; // 2. 确定交换条件, start &lt; end 允许交换 // 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end-- // for(int start = 0, end = arr.length -1; start &lt; end; start++, end--) for( ; start &lt; end; start++, end--)&#123; // 3. 循环中编写交换逻辑代码 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 3.3 二维数组概述​ 概述 : 二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器 3.4 二维数组动态初始化12345动态初始化格式：数据类型[][] 变量名 = new 数据类型[m][n];m表示这个二维数组，可以存放多少个一维数组n表示每一个一维数组，可以存放多少个元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo;public class Demo1Array &#123; /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) &#123; // 数据类型[][] 变量名 = new 数据类型[m][n]; int[][] arr = new int[3][3]; /* [[I@10f87f48 @ : 分隔符 10f87f48 : 十六进制内存地址 I : 数组中存储的数据类型 [[ : 几个中括号就代表的是几维数组 */ System.out.println(arr); /* 二维数组存储一维数组的时候, 存储的是一维数组的内存地址 */ System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[0][0]); System.out.println(arr[1][1]); System.out.println(arr[2][2]); // 向二维数组中存储元素 arr[0][0] = 11; arr[0][1] = 22; arr[0][2] = 33; arr[1][0] = 11; arr[1][1] = 22; arr[1][2] = 33; arr[2][0] = 11; arr[2][1] = 22; arr[2][2] = 33; // 从二维数组中取出元素并打印 System.out.println(arr[0][0]); System.out.println(arr[0][1]); System.out.println(arr[0][2]); System.out.println(arr[1][0]); System.out.println(arr[1][1]); System.out.println(arr[1][2]); System.out.println(arr[2][0]); System.out.println(arr[2][1]); System.out.println(arr[2][2]); &#125;&#125; 3.5 二维数组访问元素的细节问题问题 : 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 代码实现123456789101112131415161718192021222324package com.itheima.demo;public class Demo2Array &#123; /* 问题: 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 */ public static void main(String[] args) &#123; int[] arr1 = &#123;11,22,33&#125;; int[] arr2 = &#123;44,55,66&#125;; int[] arr3 = &#123;77,88,99,100&#125;; int[][] arr = new int[3][3]; arr[2][3] = 100; arr[0] = arr1; arr[1] = arr2; arr[2] = arr3; System.out.println(arr[1][2]); System.out.println(arr[2][3]); &#125;&#125; 3.6 二维数组静态初始化 **完整格式 :** 数据类型[][] 变量名 = new 数据类型[][]&#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; **简化格式 :** 数据类型[][] 变量名 = &#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; ...&#125;; **代码实现 : ** 1234567891011121314151617181920package com.itheima.demo;public class Demo3Array &#123; /* 完整格式：数据类型[][] 变量名 = new 数据类型[][]&#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; ...&#125;; 简化格式: 数据类型[][] 变量名 = &#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; ...&#125;; */ public static void main(String[] args) &#123; int[] arr1 = &#123;11,22,33&#125;; int[] arr2 = &#123;44,55,66&#125;; int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;; System.out.println(arr[0][2]); int[][] array = &#123;arr1,arr2&#125;; System.out.println(array[0][2]); &#125;&#125; 3.7 二维数组遍历需求 : ​ 已知一个二维数组 arr = {{11, 22, 33}, {33, 44, 55}}; ​ 遍历该数组，取出所有元素并打印 步骤 : 1. 遍历二维数组，取出里面每一个一维数组 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 代码实现 : 123456789101112131415161718192021222324252627package com.itheima.test;public class Test1 &#123; /* 需求: 已知一个二维数组 arr = &#123;&#123;11, 22, 33&#125;, &#123;33, 44, 55&#125;&#125;; 遍历该数组，取出所有元素并打印 步骤: 1. 遍历二维数组，取出里面每一个一维数组 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 */ public static void main(String[] args) &#123; int[][] arr = &#123;&#123;11, 22, 33&#125;, &#123;33, 44, 55&#125;&#125;; // 1. 遍历二维数组，取出里面每一个一维数组 for (int i = 0; i &lt; arr.length; i++) &#123; //System.out.println(arr[i]); // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 //int[] temp = arr[i]; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.println(arr[i][j]); &#125; &#125; &#125;&#125; 3.8 二维数组求和需求 : 某公司季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 步骤 : 定义求和变量，准备记录最终累加结果 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 遍历二维数组，获取所有元素，累加求和 输出最终结果 代码实现 : 1234567891011121314151617181920212223242526272829303132package com.itheima.test;public class Test2 &#123; /* 需求: 某公司季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 步骤: 1. 定义求和变量，准备记录最终累加结果 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 3. 遍历二维数组，获取所有元素，累加求和 4. 输出最终结果 */ public static void main(String[] args) &#123; // 1. 定义求和变量，准备记录最终累加结果 int sum = 0; // 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 int[][] arr = &#123; &#123;22,66,44&#125; , &#123;77,33,88&#125; , &#123;25,45,65&#125; , &#123;11,66,99&#125;&#125;; // 3. 遍历二维数组，获取所有元素，累加求和 for (int i = 0; i &lt; arr.length; i++) &#123; for(int j = 0; j &lt; arr[i].length; j++)&#123; sum += arr[i][j]; &#125; &#125; // 4. 输出最终结果 System.out.println(sum); &#125;&#125;","pubDate":"Mon, 01 May 2023 10:36:00 GMT","guid":"http://example.com/2023/05/01/2023-0507-0716-1.6%20Debug&%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/","category":["Java"]},{"title":"Hexo主题Yilia","link":"http://example.com/2014/08/31/hexo-theme-yilia/","description":"hexo-theme-yilia 是为 hexo 2.4+制作的主题。响应式设计，风格简约。 终于从octopress迁移到hexo。Yilia是自己设计的主题，分享之，有爱请自取。关于主题： 我喜欢简约。所以标签云，搜索框都拿掉了 接地气一点。所以用上了jiathis分享，友言评论，以及baidu的cdn 让大家把注意力放到内容上。这是本主题设计初衷 主题不支持IE6，7，8。以后也不会","pubDate":"Sun, 31 Aug 2014 08:03:00 GMT","guid":"http://example.com/2014/08/31/hexo-theme-yilia/","category":["主题","hexo"]},{"title":"Hello World","link":"http://example.com/2012/12/13/hello-world/","description":"在Winiex的推荐和帮助下，这个octopress博客终于搭建起来了。 折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。 一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个码农。 感谢Zespia提供的slash主题。我很喜欢这种色调。","pubDate":"Wed, 12 Dec 2012 17:39:00 GMT","guid":"http://example.com/2012/12/13/hello-world/","category":["杂谈","octopress"]}]}